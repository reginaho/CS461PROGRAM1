import csv
from math import radians, cos, sin, sqrt, atan2  # use for Heuristic Approaches
from collections import deque  # use for undirected (blind) brute-force approaches
import heapq
import time  # for measuring the time of the search
import sys  # for memory usage calculation (optional)
import matplotlib.pyplot as plt  # for plotting the route

# Function to build the adjacency list from the text file
def build_graph(adjacency_file):
    graph = {}
    with open(adjacency_file, 'r') as file:
        for line in file:
            city1, city2 = line.strip().split()
            if city1 not in graph:
                graph[city1] = []
            if city2 not in graph:
                graph[city2] = []
            if city2 not in graph[city1]:
                graph[city1].append(city2)
            if city1 not in graph[city2]:
                graph[city2].append(city1)
    return graph

# Function to load coordinates from the CSV file
def load_coordinates(coordinate_file):
    coordinates = {}
    with open(coordinate_file, newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            city = row[0]  # First column is the city name
            lat = float(row[1])  # Second column is latitude
            lon = float(row[2])  # Third column is longitude
            coordinates[city] = (lat, lon)
    return coordinates

# Compute the straight-line distance between two cities, used for best-first search and A*
def calculate_distance(lat1, lon1, lat2, lon2):
    R = 6371  # Earth radius in kilometers
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat/2) ** 2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2) ** 2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    return R * c

# Example to calculate distance between two cities
def get_city_distance(city1, city2, coordinates):
    lat1, lon1 = coordinates[city1]
    lat2, lon2 = coordinates[city2]
    return calculate_distance(lat1, lon1, lat2, lon2)

# Function to calculate the total distance of a path
def calculate_total_distance(path, coordinates):
    total_distance = 0
    for i in range(len(path) - 1):
        total_distance += get_city_distance(path[i], path[i+1], coordinates)
    return total_distance

# Function to plot the route on a 2D map
def plot_route(path, coordinates):
    lats = [coordinates[city][0] for city in path]
    lons = [coordinates[city][1] for city in path]

    plt.figure(figsize=(10, 8))
    plt.plot(lons, lats, marker="o", color="b", linestyle="-")
    
    for i, city in enumerate(path):
        plt.text(lons[i], lats[i], city, fontsize=12, ha='right')
    
    plt.title(f"Route from {path[0]} to {path[-1]}")
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.show()

# Optional: Function to calculate memory usage (if needed)
def calculate_memory_usage(*args):
    total_memory = sum(sys.getsizeof(arg) for arg in args)
    return total_memory


# Breadth-First Search with iteration counter
def bfs(graph, start, goal):
    queue = deque([(start, [start])])
    visited = set()
    iterations = 0  # Counter to track the number of iterations
    
    while queue:
        iterations += 1
        (current_node, path) = queue.popleft()
        if current_node in visited:
            continue
        
        if current_node == goal:
            print(f"BFS iterations: {iterations}")
            return path
        
        visited.add(current_node)
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))
    
    print(f"BFS iterations: {iterations}")
    return None

# Depth-First Search with iteration counter
def dfs(graph, start, goal, visited=None, path=None, iterations=None):
    if visited is None:
        visited = set()
    if path is None:
        path = [start]
    if iterations is None:
        iterations = [0]  # Use a list to track iterations across recursive calls
    
    iterations[0] += 1
    
    if start == goal:
        print(f"DFS iterations: {iterations[0]}")
        return path
    
    visited.add(start)
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            result = dfs(graph, neighbor, goal, visited, path + [neighbor], iterations)
            if result:
                return result
    if iterations[0] == 1:  # Print iterations only once at the end of the DFS call stack
        print(f"DFS iterations: {iterations[0]}")
    return None



# Best-First Search with iteration counter
def best_first_search(graph, start, goal, coordinates):
    def heuristic(city1, city2):
        return get_city_distance(city1, city2, coordinates)

    queue = []
    heapq.heappush(queue, (0, start, [start]))
    visited = set()
    iterations = 0  # Counter to track the number of iterations
    
    while queue:
        iterations += 1
        _, current_node, path = heapq.heappop(queue)

        if current_node in visited:
            continue

        if current_node == goal:
            print(f"Best-First Search iterations: {iterations}")
            return path

        visited.add(current_node)
        for neighbor in graph[current_node]:
            if neighbor not in visited:
                priority = heuristic(neighbor, goal)
                heapq.heappush(queue, (priority, neighbor, path + [neighbor]))

    print(f"Best-First Search iterations: {iterations}")
    return None

# A* Search with iteration counter
def optimized_a_star(graph, start, goal, coordinates):
    def heuristic(city1, city2):
        lat1, lon1 = coordinates[city1]
        lat2, lon2 = coordinates[city2]
        return abs(lat1 - lat2) + abs(lon1 - lon2)

    queue = []
    heapq.heappush(queue, (0, start, [start]))
    visited = set()
    cost_so_far = {start: 0}
    iterations = 0  # Counter to track the number of iterations

    while queue:
        iterations += 1
        cost, current_node, path = heapq.heappop(queue)

        if current_node == goal:
            print(f"A* Search iterations: {iterations}")
            return path

        if current_node in visited:
            continue

        visited.add(current_node)
        for neighbor in graph[current_node]:
            new_cost = cost_so_far[current_node] + get_city_distance(current_node, neighbor, coordinates)
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost + heuristic(neighbor, goal)
                heapq.heappush(queue, (priority, neighbor, path + [neighbor]))

    print(f"A* Search iterations: {iterations}")
    return None

# Updated main function to use modified search methods with iteration counters
def main():
    graph = build_graph('Adjacencies.txt')
    coordinates = load_coordinates('coordinates.csv')
    
    while True:
        start = input("Enter starting city: ")
        goal = input("Enter destination city: ")
        
        if start not in graph or goal not in graph:
            print("Invalid cities. Please enter valid city names.")
            continue
        
        print("Choose a search method:")
        print("1: BFS")
        print("2: DFS")
        print("3: ID-DFS")
        print("4: Best-First Search")
        print("5: A* Search")

        method = input("Enter the number of the search method: ")

        start_time = time.perf_counter()

        if method == "1":
            path = bfs(graph, start, goal)
        elif method == "2":
            path = dfs(graph, start, goal)
        elif method == "3":
            path = iddfs(graph, start, goal, max_depth=5)
        elif method == "4":
            path = best_first_search(graph, start, goal, coordinates)
        elif method == "5":
            path = optimized_a_star(graph, start, goal, coordinates)
        else:
            print("Invalid choice. Please enter a number between 1 and 5.")
            continue

        end_time = time.perf_counter()
        elapsed_time = end_time - start_time
        print(f"Path found: {path}")
        print(f"Time taken: {elapsed_time:.6f} seconds")

if __name__ == "__main__":
    main()